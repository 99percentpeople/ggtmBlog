//! SeaORM Entity. Generated by sea-orm-codegen 0.7.0
use sea_orm::entity::prelude::*;
use sea_orm::Set;
use serde::{Deserialize, Serialize};

use chrono::{NaiveDateTime, Utc};
pub mod blog {
    use sea_orm::ActiveValue::{self, NotSet};

    use super::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize, Serialize)]
    #[sea_orm(table_name = "t_blog")]
    pub struct Model {
        #[sea_orm(primary_key)]
        #[serde(skip_deserializing)]
        pub id: i32,
        #[sea_orm(unique)]
        pub title: String,
        pub summary: Option<String>,
        pub content: String,
        pub cover: Option<String>,
        pub flag: Flag,
        #[serde(skip_deserializing, default)]
        pub views: i32,
        pub appreciation: bool,
        pub share_statement: bool,
        pub enable_comment: bool,
        #[serde(default)]
        pub published: bool,
        pub recommend: bool,
        #[serde(skip_deserializing)]
        pub create_time: Option<NaiveDateTime>,
        #[serde(skip_deserializing)]
        pub update_time: Option<NaiveDateTime>,
        pub sort_id: i32,
        #[serde(skip_deserializing)]
        pub user_id: i32,
        #[sea_orm(ignore)]
        pub tag_ids: Vec<i32>,
    }
    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {
        #[sea_orm(
            belongs_to = "super::sort::Entity",
            from = "Column::SortId",
            to = "super::sort::Column::Id",
            on_update = "Cascade"
        )]
        Sort,
        #[sea_orm(
            belongs_to = "super::user::Entity",
            from = "Column::UserId",
            to = "super::user::Column::Id",
            on_update = "Cascade"
        )]
        User,
        #[sea_orm(has_many = "super::comment::Entity")]
        Comment,
    }
    #[derive(Debug, Clone, PartialEq, EnumIter, DeriveActiveEnum, Deserialize, Serialize)]
    #[sea_orm(rs_type = "String", db_type = "String(Some(1))")]
    pub enum Flag {
        #[sea_orm(string_value = "original")]
        Original,
        #[sea_orm(string_value = "reprint")]
        Reprint,
        #[sea_orm(string_value = "translate")]
        Translate,
    }
    impl Related<super::sort::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Sort.def()
        }
    }
    impl Related<super::user::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::User.def()
        }
    }
    impl Related<super::comment::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Comment.def()
        }
    }
    impl Related<super::tag::Entity> for Entity {
        fn to() -> RelationDef {
            super::blogs_tags::Relation::Tag.def()
        }

        fn via() -> Option<RelationDef> {
            Some(super::blogs_tags::Relation::Blog.def().rev())
        }
    }
    impl ActiveModelBehavior for ActiveModel {
        fn before_save(mut self, insert: bool) -> Result<Self, DbErr> {
            if insert {
                self.views = Set(0);
                self.id = NotSet;
                self.create_time = Set(Some(Utc::now().naive_utc()));
            } else if let ActiveValue::Set(_) = self.views {
            } else {
                self.update_time = Set(Some(Utc::now().naive_utc()));
            }
            Ok(self)
        }
    }
}
pub mod tag {
    use super::*;
    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize, Serialize)]
    #[sea_orm(table_name = "t_tag")]
    pub struct Model {
        #[sea_orm(primary_key)]
        #[serde(skip_deserializing)]
        pub id: i32,
        #[sea_orm(unique)]
        pub name: String,
        #[sea_orm(ignore)]
        #[serde(skip_deserializing)]
        pub blog_count: i32,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl Related<super::blog::Entity> for Entity {
        fn to() -> RelationDef {
            super::blogs_tags::Relation::Tag.def()
        }

        fn via() -> Option<RelationDef> {
            Some(super::blogs_tags::Relation::Blog.def().rev())
        }
    }

    impl ActiveModelBehavior for ActiveModel {}
}
pub mod blogs_tags {
    use super::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize, Serialize)]
    #[sea_orm(table_name = "t_blogs_tags")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub blog_id: i32,
        #[sea_orm(primary_key)]
        pub tag_id: i32,
    }
    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {
        #[sea_orm(
            belongs_to = "super::blog::Entity",
            from = "Column::BlogId",
            to = "super::blog::Column::Id",
            on_update = "Cascade",
            on_delete = "Cascade"
        )]
        Blog,
        #[sea_orm(
            belongs_to = "super::tag::Entity",
            from = "Column::TagId",
            to = "super::tag::Column::Id",
            on_update = "Cascade",
            on_delete = "Cascade"
        )]
        Tag,
    }
    impl ActiveModelBehavior for ActiveModel {}

    impl From<(i32, i32)> for Model {
        fn from((blog_id, tag_id): (i32, i32)) -> Self {
            Self { blog_id, tag_id }
        }
    }
}

pub mod sort {
    use super::*;
    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize, Serialize)]
    #[sea_orm(table_name = "t_sort")]
    pub struct Model {
        #[sea_orm(primary_key)]
        #[serde(skip_deserializing)]
        pub id: i32,
        #[sea_orm(unique)]
        pub name: String,
        #[sea_orm(ignore)]
        #[serde(skip_deserializing)]
        pub blog_count: i32,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {
        #[sea_orm(has_many = "super::blog::Entity")]
        Blog,
    }

    impl Related<super::blog::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Blog.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {}
}
pub mod comment {
    use super::*;
    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize, Serialize)]
    #[sea_orm(table_name = "t_comment")]
    pub struct Model {
        #[sea_orm(primary_key)]
        #[serde(skip_deserializing)]
        pub id: i32,
        pub id_ref: Option<i32>,
        pub nickname: String,
        #[serde(skip_serializing)]
        pub email: String,
        pub content: String,
        pub avatar: Option<String>,
        #[serde(skip_deserializing)]
        pub like: Option<i32>,
        #[serde(skip_deserializing)]
        pub dislike: Option<i32>,
        #[serde(skip_deserializing)]
        pub create_time: Option<NaiveDateTime>,
        #[serde(skip_deserializing)]
        pub blog_id: i32,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {
        #[sea_orm(
            belongs_to = "super::blog::Entity",
            from = "Column::BlogId",
            to = "super::blog::Column::Id",
            on_delete = "Cascade",
            on_delete = "Cascade"
        )]
        Blog,
        #[sea_orm(has_many = "Entity")]
        Comment,
        #[sea_orm(
            belongs_to = "Entity",
            from = "Column::IdRef",
            to = "Column::Id",
            on_delete = "Cascade",
            on_delete = "Cascade"
        )]
        SubComment,
    }

    impl Related<super::blog::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Blog.def()
        }
    }
    impl Related<Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Comment.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {
        fn before_save(mut self, insert: bool) -> Result<Self, DbErr> {
            if insert {
                self.create_time = Set(Some(Utc::now().naive_utc()))
            }
            Ok(self)
        }
    }

    pub struct SubCommentLink;
    impl Linked for SubCommentLink {
        type FromEntity = Entity;

        type ToEntity = Entity;

        fn link(&self) -> Vec<RelationDef> {
            vec![Relation::SubComment.def().rev()]
        }
    }
}

pub mod user {
    use super::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize, Serialize)]
    #[sea_orm(table_name = "t_user")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        pub nickname: Option<String>,
        #[sea_orm(unique)]
        pub username: String,
        pub password: String,
        pub email: Option<String>,
        pub avatar: Option<String>,
        #[serde(skip_serializing)]
        pub access_level: Option<i32>,
        pub create_time: Option<NaiveDateTime>,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {
        #[sea_orm(has_many = "super::blog::Entity")]
        Blog,
        #[sea_orm(has_many = "super::file::Entity")]
        File,
    }

    impl Related<super::blog::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Blog.def()
        }
    }
    impl Related<super::file::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::File.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {
        fn before_save(mut self, insert: bool) -> Result<Self, DbErr> {
            if insert {
                self.create_time = Set(Some(Utc::now().naive_utc()));
                self.access_level = Set(Some(1))
            }
            Ok(self)
        }
    }
}

pub mod file {
    use super::*;
    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Deserialize, Serialize)]
    #[sea_orm(table_name = "t_file")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        #[sea_orm(unique)]
        #[serde(skip_serializing)]
        pub path: String,
        pub file_type: Option<String>,
        pub file_name: Option<String>,
        pub user_id: i32,
    }
    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {
        #[sea_orm(
            belongs_to = "super::user::Entity",
            from = "Column::UserId",
            to = "super::user::Column::Id"
            on_update = "Cascade",
            on_delete = "Cascade"
        )]
        User,
    }
    impl Related<super::user::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::User.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {}
}
